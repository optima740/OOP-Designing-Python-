# Принцип открытости-закрытости модуля OCP.
# ЗАДАНИЕ 4

""" Согласно принципу OCP (открытости-закрытости модуля) создаваемые модули (классы)
в проекте должны соответствовать двум критериям: Быть открытыми для добавления нового функционала
и быть максимально закрытыми для изменений. Другими словами, любые изменения в коде должны производится
путем добавления нового кода, а не внесением правок в существующий.
Для решения такой задачи подходит принцип абстракций и использование наследования.
За базовый класс мы берем абстрактный класс. Далее мы его реализуем. И если нам потребуется расширить функционал,
мы наследуемся от реализованного класса, и расширяем в нашем наследнике функционал.
Если попробовать описать такую иерархию классов, то скорее это будет выглядеть так:
у нас есть абстрактный базовый класс «абстрактный повар» с функционалом «готовить еду».
Далее мы реализуем этот класс как «повар», в котором мы реализовали метод «готовить еду».
Также мы создаем абстрактный класс «абстрактное меню». И реализуем его в виде класса «меню».
Так вот в нашем примере, открытость будет заключаться в том, что метод «готовить еду» класса «повар»
должен принимать наследников класса «меню» при любом расширении/изменении реального меню. То есть в
возможности расширения функционала за счет наследования класса «меню». А закрытость, в свою очередь,
заключается в том, что в методе «готовить еду» класса «повар», не должно быть реализации функционала
что именно мы готовим и как готовим. Он должен принимать, например, объект класса «меню» и обрабатывать его.
Наверное, еще стоит добавить, что закрытость модулей обеспечивается применением
модификаторов доступа (В С++ это Private, в Python это двойное нижнее подчеркивание
в начале имени), также нужно стараться не использовать глобальные переменные, т.к их изменение может повлечь
изменение других сущностей которые их используют. Другими словами, сущности класса должны быть максимально
закрыты от использования их за пределами класса – это называется инкапсуляция.
"""
# Принципы повторного использования модуля.
# ЗАДАНИЕ 5

"""
1.	Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать 
параметризацию другими типами (обобщённые типы, типы-генерики). -- Не применим для Python.

В Python используется динамическая типизация. Таким образом, типизация  
переменных, методов и классов по факту автоматическая, и интерпретатор языка практически ничего серьезно 
проверить не может, тем более обобщенные типы. По этому, за соблюдение того, что тип данных 
(или входных параметров функции) будет совместим с кодом, отвечает разработчик. В коде необходимо 
использовать различные ограничения (проверки) правильности типа данных, для того чтобы не получить 
скрытые и трудно выявляемые баги. 

2.	Новый модуль может объединять несколько функций, которые активно обращаются друг к другу. -- Применим для Python.

Модуль как класс, может нести в себе некий функционал (объединять несколько методов) которые взаимодействуют внутри 
класса (скрытая реализация), однако доступ к ним из вне, организован по определенному интерфейсу (публичный доступ).

3.	Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, 
которую не удаётся решить с помощью одного модуля. -- Применим для Python.

Наследование в Python представляет собой иерархию классов (семейство модулей, организованных для решения общей задачи). 
От базового (object) до текущего. Например, при вызове метода, он сначала ищется в текущем классе и, 
если метод не найден, поиск будет продолжен по всей иерархии, пока данный метод не будет найден в 
родительских классах. Либо мы получим ошибку. 

4.	Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться 
динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра -- 
не применим в Python.

Данный пункт подразумевает использование конкретной реализации абстрактных модулей. Конкретная реализация 
родительского модуля будет выбрана программистом.  


5.	Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями -- применим 
в Python. 

Новый модуль может содержать в себе общее поведение нескольких модулей (родительских классов) при множественном 
наследовании (отношение "is-a"), а так же, при агрегации  в себе объектов других модулей (классов) – композиция
(отношение "has-a").

"""
# ЗАДАНИЕ 6.

# Существуют ли ситуации, когда связи между модулями должны делаться публичными?
"""Я думаю, что публичные связи делаются в том случае, когда необходимо организовать зависимости между классами. 
Изменения в независимом классе влияют на другие зависимые классы."""
# Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
"""При модульном подходе в ООП, при декомпозиции общей задачи на более, мелкие каждую из отделенных под-задач, в идеале, 
должен решать отдельный модуль. При построении модульной структуры программы важно составить такую компоицию модулей,
которая позволила бы свести к минимальному кол-ву связей между ними."""
# Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим
# метрикам?
""" Набор классов и функций имеющих множество связей между своими элементами логичней всего распологать в одином модуле. 
Также у модуля должен быть удобный интерфейс: набор функций(методов), которые данный модуль предлагает пользователю 
(публичный доступ)"""

