# Принцип открытости-закрытости модуля OCP.
# ЗАДАНИЕ 4

""" Согласно принципу OCP (открытости-закрытости модуля) создаваемые модули (классы)
в проекте должны соответствовать двум критериям: Быть открытыми для добавления нового функционала
и быть максимально закрытыми для изменений. Другими словами, любые изменения в коде должны производится
путем добавления нового кода, а не внесением правок в существующий.
Для решения такой задачи подходит принцип абстракций и использование наследования.
За базовый класс мы берем абстрактный класс. Далее мы его реализуем. И если нам потребуется расширить функционал,
мы наследуемся от реализованного класса, и расширяем в нашем наследнике функционал.
Если попробовать описать такую иерархию классов, то скорее это будет выглядеть так:
у нас есть абстрактный базовый класс «абстрактный повар» с функционалом «готовить еду».
Далее мы реализуем этот класс как «повар», в котором мы реализовали метод «готовить еду».
Также мы создаем абстрактный класс «абстрактное меню». И реализуем его в виде класса «меню».
Так вот в нашем примере, открытость будет заключаться в том, что метод «готовить еду» класса «повар»
должен принимать наследников класса «меню» при любом расширении/изменении реального меню. То есть в
возможности расширения функционала за счет наследования класса «меню». А закрытость, в свою очередь,
заключается в том, что в методе «готовить еду» класса «повар», не должно быть реализации функционала
что именно мы готовим и как готовим. Он должен принимать, например, объект класса «меню» и обрабатывать его.
Наверное, еще стоит добавить, что закрытость модулей обеспечивается применением
модификаторов доступа (В С++ это Private, в Python это двойное нижнее подчеркивание
в начале имени), также нужно стараться не использовать глобальные переменные, т.к их изменение может повлечь
изменение других сущностей которые их используют. Другими словами, сущности класса должны быть максимально
закрыты от использования их за пределами класса – это называется инкапсуляция.
"""
# Принципы повторного использования модуля.
# ЗАДАНИЕ 5

"""
1.	Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать 
параметризацию другими типами (обобщённые типы, типы-генерики).

В Python используется динамическая типизация. Принцип «утиной типизации» говорит о том, 
что если что-то ведет себя как утка то, вероятнее всего, это и есть утка. Таким образом, типизация  
переменных, методов и классов по факту автоматическая. По этому, за соблюдение того, что тип данных 
(или входных параметров функции) будет совместим с кодом, отвечает разработчик. В коде необходимо 
использовать различные ограничения (проверки) правильности типа данных, для того чтобы не получить 
скрытые и трудно выявляемые баги. 

2.	Новый модуль может объединять несколько функций, которые активно обращаются друг к другу.

Сущности модуля (класса) активно взаимодействуют друг с другом, при этом взаимодействие их с сущностями 
других классов, по возможности, ограничена. Если я правильно понял, это принцип инкапсуляции. Инкапсуляция 
реализуется использованием модификаторов доступа и ограничением на использование методов других классов. 

3.	Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, 
которую не удаётся решить с помощью одного модуля.

Наследование в Python представляет собой иерархию классов (семейство модулей, организованных для решения общей задачи). 
От базового (object) до текущего. Например, при вызове метода, он сначала ищется в текущем классе и, 
если метод не найден, поиск будет продолжен по всей иерархии, пока данный метод не будет найден в 
родительских классах. Либо мы получим ошибку. 

4.	Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться 
динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра.

Данный пункт подразумевает использование наследования со специализацией. Когда класс потомок переопределяет методы 
(функционал) родителя для более специализированного использования. Переопределение (перегрузка) методов 
поддерживается в Python. По сути, это инструмент для реализации полиморфизма. Если нам необходимо переопределить метод, 
но часть кода использовать от родительского метода, мы используем функцию super(method). Которая вызывает указанный в 
своих аргументах метод у класса родителя из иерархии классов. Кроме того, в Python присутствуют так называемые 
магические методы. Например вызов __init__()  – перегружает (переопределяет) конструктор данного класса. 

5.	Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями.

В данном пункте, насколько я понимаю, идет речь о множественном наследовании и/или о композиции. 
Новый модуль может содержать в себе общее поведение нескольких модулей (родительских классов) при множественном 
наследовании (отношение "is-a"), а так же, при агрегации  в себе объектов других модулей (классов) – композиция
(отношение "has-a").

"""
# ЗАДАНИЕ 6.
"""В данном задании, я не уверен, что до конца правильно понял вопросы и, возможно, рассуждаю не в том русле."""
# Существуют ли ситуации, когда связи между модулями должны делаться публичными?
"""Я думаю, что публичные связи делаются в том случае, когда необходимо организовать зависимости между классами. 
Изменения в независимом классе влияют на другие зависимые классы."""
# Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
# Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим
# метрикам?
"""Допустим у нас есть семейство классов, организованных для решения общей задачи. 
Все наши классы имеют одинаковый тип данных (по сути структура данных не меняется), различаются только 
действия над данными, т. е методы класса (функционал). Возможно, в таком случае, можно все это семейство 
классов объединить в один модуль. 
Соответственно, метрикой в данном случае будет служить факт необходимости создавать другой тип данных. 
Например, мы можем наследовать от базового типа «транспортное средство» сколь угодно раз, пока мы имеем дело 
с транспортным средством. Будет меняться лишь функционал. Но вот когда нам понадобится, например, тип данных 
«животное», то семейство классов наследников от класса «животное» мы объединим в другой модуль."""

