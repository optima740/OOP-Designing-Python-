# ЗАДАНИЕ 20.

"""
Наследование реализации.
Например, у нас есть абстрактный (частично реализованный) класс «Фигура». Мы описываем внутри данного класса
виртуальную (или в случае Python абстрактную) функцию get_area() – нахождение площади фигуры. И функцию print_name()
– возвращающую имя фигуры, которую тут же реализовываем в нашем абстрактном классе.
Если мы создадим на основе нашего абстрактного класса, например, класс «Прямоугольник»,
то класс потомок унаследует две функции от класса-родителя:
get_area()  – виртуальная функция, которая требует реализации в классе потомке и может быть переопределена в дальнейшем
(т.к площадь у разных фигур вычисляется по-разному).
get_name() – инвариант, реализация которой уже задана и не подразумевает переопределение в классах-потомках.
(т.к механизм доступа к полю имени фигуры везде одинаков).
Тем самым мы получаем два подвида наследования реализаций. В первом случае – наследуем интерфейс и необходимость
обязательной реализации в классе-потомке, во втором случае, наследуется реализация, не требующая переопределения.
"""

from abc import ABC, abstractmethod

class AbstractShape(ABC):
    # абстрактный класс Фигура.
    CONST_AREA_NIL = 0
    CONST_AREA_OK = 1
    CONST_ARER_ERR = 2
    CONST_GET_NAME_NIL = 0
    CONST_GET_NAME_OK = 0

    # предусловие: входные величины - положительные
    def __init__(self, name):
        # инициализация.
        self.Shape_name = name
        self.get_name_status = self.CONST_GET_NAME_NIL

    # постусловие: площадь не равна нулю.
    @abstractmethod
    def get_area(self):
        # метод получения площади. Не реализован и должен быть реализован для конкретной фигуры с возможностью
        # переопределения
        pass

    def get_name(self):
        # метод возвращает имя фигуры. Уже реализован и не должен переопределяться в классах-потомках.
        self.get_name_status = self.CONST_GET_NAME_OK
        return self.Shape_name

import  math
class Rectangle(AbstractShape):
    # В классе Прямоугольник, наследуем реализацию функции get_name() и интерфейс get_area().

    def __init__(self, name, a, b):
        # используем модуль величины, в случае, если были приняты отрицательные значения.
        super().__init__(name)
        self.length = math.fabs(a)
        self.height = math.fabs(b)
        self.get_area_status = self.CONST_AREA_NIL

    def get_area(self):
        # Реализуем родительский метод нахождения площади для Прямоугольника.
        result = self.length * self.height
        if result != 0:
            self.get_area_status = self.CONST_AREA_OK
            return result
        self.get_area_status = self.CONST_ARER_ERR

"""
Льготное наследование.
Данный тип наследования носит, скорее, исключительный характер. Данный вид наследования можно применить, когда нам 
необходимо объединить какие-либо поля для использования в виде единого функционала в других классах. Например, 
при помощи такого вида наследования, можно создать иерархию классов-статусов для отображения статуса заказа. 
"""

class OrderStatus(object):
    # базовый класс для статуса заказа.
    def __init__(self):
        self.status = 'Status'

    def get_status(self):
        # метод получения данных о статусе.
        return self.status

class OrderInWorkStatus(OrderStatus):
    # потомок для класса-статуса заказа
    def __init__(self):
        # переопределение поля.
        self.status = 'in work'

class OrderDoneStatus(OrderStatus):
    # потомок для класса-статуса заказа
    def __init__(self):
        # переопределение поля.
        self.status = 'done'