# Статическое и динамическое связывание.

"""
Я хотел бы сначала привести немного той теории, которая уложилась у меня в голове по данной теме:

Связывание  - подстановка в код программы вызова конкретного метода.
При статическом (раннем) связывании компилятор «знает» какой метод вызвать в конкретном месте кода на раннем этапе –
этапе компиляции.
При динамическом связывании (позднем), связывание происходит при выполнении программы, т.е. при создании объекта.
Нужный метод полиморфного объекта будет определен динамически, в ходе работы программы.
Виртуальная функция – функция для которой связывание (вызов в коде) происходит во время выполнения программы т.е
динамически. (в отличие от обычной функции, для которой связывание происходит на этапе компиляции).
Также виртуальная функция - это функция, которая определена в базовом  классе, а любой класс потомок может ее
переопределить.
Виртуальная функция вызывается только через ссылку на базовый класс. Выбор функции для вызова зависит от того,
на экземпляр какого класса при выполнении программы указывает ссылка. Проще говоря, виртуальная функция – это
ссылка на функцию родителя, которую каждый класс-потомок может переопределить на собственную.
"""
# ЗАДАНИЕ 7. Пример динамического связывания.
class A:
    # класс А
    def foo(self, x, y):
        return x + y

    def bar(self, a):
        return a

class B(A):
    # класс B наследуется от класса А
    def foo(self, x, y):
        # переопределена функция родительского класса
        return x * y

    def bar(self, a):
        # переопределена функция родительского класса
        return a * a

a = A() # создаем экземпляр класса A.
b = B() # создаем экземпляр класса B.
print(a.foo(1, 2)) # смотрим результат вызова метода foo родительского класса A.
print(b.foo(1, 2)) # смотрим результат вызова метода foo класса приемника B.
b = a  # теперь b содержит ссылку на экземпляр класса A.
print(b.foo(1, 2)) # в данном случае при динамическом связывании , происходит вызов метода по
                   # ссылке на объект класса A (при выполнении программы).

"""
Ковариантность и контравариантность.
Ковариантность – иерархия наследования распространяется от общего типа к специализированному, более частному т.е в прямом порядке.
Контравариантность – иерархия наследования распространяется от более частного случая к общему, т. е. обратном порядке.

"""
# ЗАДАНИЕ 8.
# у нас есть иерархия классов:
class device:
    # базовый класс устройство.
    def on(self):
        # функция включить.
        pass

    def off(self):
        # функция выключить.
        pass

class keyboard(device):
    # потомок класса device, имеющий более специаллизированый функционал.
    pass


"""если рассматривать данную иерархию классов с точки зрения множеств, то keyboard является подмножеством множества 
device т.о мы имеем ковариантность - наследование передалось в прямом виде.

Если мы, например, создадим функцию Action, которая будет принимать в качестве входного параметра класс(экземпляр 
класса). А также представим обратную иерархию классов device, как наследник keyboard (как расширение), то получится, 
что действие над устройством будет частным случаем действия над клавиатурой, ведь совершенно не факт, 
что в нашем device предусмотрены кнопки. Но если функция Action может выполнить что-то над device, 
то она может это выполнить и над keyboard.
"""
def Action(var):
    # выполняет роль делегата - производит действие над объектом.
    pass

class keyboard1:
    # в данном случае базовый класс.
    def press_key(self):
        # функция нажатия кнопки.
        pass

class device1(keyboard1):
    # в данном случае класс-потомок.
    def on(self):
        # функция включить.
        pass

    def off(self):
        # функция выключить.
        pass

dev = device1() # экземпляр класса device1
kbrd = keyboard1() # экземпляр класса keyboard1

Action(dev) # является частным случаем.
Action(kbrd) # является общим случаем.

"""Таким образом мы видим, что наследование передается в обратном порядке, то есть мы имеем контравариантность"""



